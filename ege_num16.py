def f(n):  # в первом варианте достаточно просто переписать функцию и выполнить с ней действия указанные в задание
    if n < 4:
        return 1
    if n > 3 and n % 2 != 0:
        return n
    return f(n - 1) + f(n - 2) + f(n - 3)


def hard():  # Второй вариант. В нем надо писать список, а не функцию
    # Чтобы полностью понять пример, откройте задание, которое разбарается
    lst = [1, 1, 1, 1] # Создаем список, который содержит такое количество значений, зказанных при возвращении константы(в нашел случае от нуля до трех функция возвращает 1, поэтому в списке изначально в функции должно быть 3+1 единицы)
    for i in range(4, 2255): # Начинаем перебор от того момента, когда выполниться второе условие, в нашел случае от 4
        if i % 2 != 0:
            lst.append(i) # По условию просто его добавляем
        else:
            lst.append(lst[i - 1] + lst[i - 2] + lst[i - 3]) # здесь добавляем значение, заменив F на lst
    print(lst[2254] - lst[2252]) # Выводим результат также просто заменив F на lst



def main():
    # print(f(2254) - f(2252))  # Первый вариант
    hard()


if __name__ == '__main__':
    main()

# Задача имеет два варианта
# 1) Когда вызываемая функция работает быстро и не уходит в недоупстимое количество самовызовов
# 2) Когдда вункция работает долго или происзодит недоупстимое количество самовызовов
