def f(n):  # в первом варианте достаточно просто переписать функцию и выполнить с ней действия указанные в задание
    if n <= 3:
        return n
    if n > 3 and n % 2 == 0:
        return 2 * n * n + f(n - 1)
    return n * n * n + n + f(n - 1)


def hard():  # Второй вариант. В нем надо писать список, а не функцию
    # Чтобы полностью понять пример, откройте задание, которое разбарается
    lst = [1, 1, 1,
           1]  # Создаем список, который содержит такое количество значений, зказанных при возвращении константы(в нашел случае от нуля до трех функция возвращает 1, поэтому в списке изначально в функции должно быть 3+1 единицы)
    for i in range(4, 2029):  # Начинаем перебор от того момента, когда выполниться второе условие, в нашел случае от 4
        # if i % 2 != 0:
        #     lst.append(i)  # По условию просто его добавляем
        # else:
        #     lst.append(lst[i - 1] + lst[i - 2] + lst[i - 3])  # здесь добавляем значение, заменив F на lst
        lst.append((i + 3) * lst[i - 2])
    print(lst[2028] / lst[2024])  # Выводим результат также просто заменив F на lst


def main():
    k = 0
    for i in range(10000):
        if f(i) <10 ** 7:
            k += 1
        else:
            break
    print(k)
    # print(f(2254) - f(2252))  # Первый вариант
    # hard()


if __name__ == '__main__':
    main()

# Задача имеет два варианта
# 1) Когда вызываемая функция работает быстро и не уходит в недоупстимое количество самовызовов
# 2) Когдда вункция работает долго или происзодит недоупстимое количество самовызовов
